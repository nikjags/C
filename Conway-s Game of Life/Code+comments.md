# Игра "Жизнь". Пример реализации.



**Игра  "Жизнь"** (англ. *Conway's Game of Life*) — клеточный автомат, придуманный английским математиком Джоном Конвеем в 1970 году.

Действие игры происходит на клеточном поле.

![](https://media.giphy.com/media/yxIZRnUVv5HtC/giphy.gif)

В программе клеточное поле представлено в виде двумерного массива.

В нашем случае поле будет размером W на H и задаваться в коде программы, но также возможен ввод размеров поля с клавиатуры, из файла или с помощью интерфейса.

Каждая клетка может быть либо жива, либо мертва.

Первое, что необходимо сделать - это задать первое (начальное) поколение.

В нашем случае первое поколение задавается в коде программы, но также возможен ввод размеров поля с клавиатуры, из файла или с помощью интерфейса.

Каждое следующее поколение рассчитывается на основе предыдущего по таким правилам:
- в пустой (мёртвой) клетке, рядом с которой ровно три живые клетки, зарождается жизнь;
- если у живой клетки есть две или три живые соседки, то эта клетка продолжает жить; в противном случае, если соседей меньше двух или больше трёх, клетка умирает («от одиночества» или «от перенаселённости»);

Игра прекращается, если живых клеток не осталось, либо конфигурации клеток постоянно повторяются без изменений.

Основная задача нашей программы: разработать функцию, рассчитывающую следующее поколение на основе предыдущего (которое будет получено на входе в функцию). В нашем случае это будет функция next_gen.

Основной код программы содержится в функциях:
- ввода первого поколения - *input_first_gen*;
- вывода поколения - *print_gen*;
- получения следующего поколения *next_gen*;

Некоторые комментарии к программе:

Функции ввода первого поколения и вывода текущего поколения могут быть иными, в зависимости от реализации интерфейса.

Enjoy!

```C
#include <stdio.h>
#include <stdlib.h> //Для команды system, чтобы очищать экран между поколениями (хотя бы попытаться).

#define W 30 //Задаем ширину поля
#define H 30 //Задаем высоту поля

//Функция, получающая следующее поколение.
void next_gen(int prev[W][H]); //На вход поступает предыдущее поколение.
//Функция ввода первого поколения
void input_first_gen(int gen[W][H]);
//Вывод поколения на экран
void print_gen(int gen[W][H]);

int main ()
{
  int gen[W][H];
  int i, j;

  //Вводим первое поколение
  input_first_gen(gen);

  //Выводим первое поколение
  printf("Первое поколение:\n");
  print_gen(gen);

  //Игра в жизнь начинается!
  while(1) {
    //Получаем следующее поколение из предыдущего
    next_gen(gen);

    //Выводим текущее поколение
    print_gen(gen);
  }
}

//Функция, получающая следующее поколение.
void next_gen(int prev[W][H]) //На вход поступает предыдущее поколение.
{
  int next[W][H]; //Массив следующего поколения
  int i,j,cell;
  for (i=1;i<=W-2;i++) {
    for (j=1;j<=H-2;j++) {
	    cell = prev[i-1][j-1] + prev[i-1][j] + prev[i-1][j+1]
	         + prev[i]  [j-1] + prev[i]  [j+1] + prev[i+1][j-1]
	         + prev[i+1][j] + prev[i+1][j+1]; //Определяем количество соседей у клетки с координатами (i,j) в предыдущем поколении
	    if (prev[i][j] == 1) { //Если клетка в прошлом поколении жива...
	      if ((cell == 3) || (cell == 2)) { //... и если у клетки 2 или 3 соседа,..
		 	    next[i][j] = 1;  //... то в следующем поколении клетка выживает.
		    } else {
		      next[i][j] = 0;  //Иначе в следующем поколении клетка умирает. :(		  
		    }
	    } else { //Если в месте (i,j) не существовало в предыдущем поколении...
	      if (cell == 3) { //... и если соседей трое,..	      
	   		  next [i][j] = 1;//то клетка рождается.
		    } else next[i][j] = 0; //Иначе клетка не рождается.
	    }
	    cell=0; //обнуляем счетчик соседей клетки.
	  }
  }

  for (i=1;i<=W-2;i++) { //В массив предыдущего поколения записываем массив следующего поколения.
    for (j=1;j<=H-2;j++) {
	    prev[i][j]=next[i][j];
	  }
  }
}

//Функция ввода первого поколения
void input_first_gen(int gen[W][H])
{
  int i,j;
  for (i=1;i<=W-2;i++) {
    for (j=1;j<=H-2;j++) {
      gen [i][j] = 0; //Обнуляем все поколение
    }
  }
  /*Вводим живые клетки первого поколения*/
  gen[15][4]  = 1;
  gen[15][5]  = 1;
  gen[15][6]  = 1;
  gen[16][5]  = 1;
  gen[17][5]  = 1;
  gen[17][6]  = 1;
  gen[17][7]  = 1;
  gen[18][9]  = 1;
  gen[18][10] = 1;
  gen[18][8]  = 1;
}

//Вывод поколения на экран
void print_gen(int gen[W][H])
{
  int i,j;

  system("cls"); //Необязательная команда для очистки экрана
  for(i=1;i<=W-2;i++) printf("_"); //Табличка для поколения
  printf("\n");

  for (i=1;i<=W-2;i++) {
	  for (j=1;j<=H-2;j++) {
	    if(gen[i][j]==1) {
		    printf ("@");
		  } else {
		    printf(" ");
      }
	  }
	  printf("|\n");
  }

  for(i=1;i<=W-2;i++)
    printf("_");
  printf("|\n");

  printf("Для вывода следующего поколения нажмите Enter\n");
  getchar(); //Ждем подтверждения ввода с помощью клавиши Enter. Таким образом реализована пауза в выводе между поколениями.
  printf("\n");
}
```

Первое поколение выглядит так:

![](Pictures/begin.jpg)

Конец эволюции выглядит так:

![](Pictures/end.jpg)  

# Задание

Дано зашифрованное с помощью шифра Атбаш сообщение. Создать программу, в которой на вход поступает зашифрованное сообщение, а на выход - расшифрованное.

Шифр Атбаш - простой шифр, в котором i-ая буква алфавита меняется на n-i+1 букву (где n - число букв в алфавите). Например, буква *а* будет заменена на *я*, *б* будет заменена на *ю* и так далее.

Алфавит - русский. Прописные буквы заменяются на строчные, строчные заменяются на прописные. Знаки препинания и пробелы сохранены.

Зашифрованное сообщение для примера:

Тцо поъфоянъс, ц э вмрт энъ ыъур. Рс мъопъуцэр оячеансаъм сят эъуцфлб цнмцсл, нрнмраёлб э мрт, змр лт ц ыяшъ нъоыиъ – сцзмр. Я фятъсг, нрьоъмдх нрусиът, цуц фцпяоцн, фрмродх фяшъмна ъёъ эджъ ся крсъ ансрьр съюя, рзъозцэябм ъыцснмэъссдх тцо, ьыъ прсамцъ «юдмг пояэдт» рюоъмяъм нтдну, – поцорыл юъч зъурэъфя. Вмрм тцо тъса лсцзмршяъм. Рс нмцояъм тъса н уция чътуц. Рс рмоцияъм тъса юъч ьсъэя. Я а, нтцоцэжцхна ц прюъшыъссдх, лнмоътуабнг ся прцнфц тлыорнмц, фрмрорх энъ лшъ прыэуянмср, – мругфр юд нуъчд съ чянмцуяуц тсъ эчро ц мругфр юд ьортфръ одыясцъ првчцц, оянпцоябёъъ тсъ ьолыг, съ чянмяэцур тъса чяюдмг р пояэыъ тцоя.
