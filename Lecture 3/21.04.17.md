# Лекция 3

Темы, которые будут рассмотрены в этой лекции:

- Тип данных структура;
- Тип данных объединение;
- Подробнее о препроцессоре и его директивы;
- Операция typedef;
- Динамическое распределение памяти;
- Пример использования динамического распределения памяти;
- Использование структур и динамически выделенной памяти для реализации структур данных. Стек, деревья и другие.

## Структура 

В языке C существует способ построения сложных типов данных путем объединения уже существующих типов в структуры. Описание структуры имеет вид:
```C
struct имя_типа_структуры 
{
  тип_данных имя_переменной;
  тип_данных имя_переменной;
  ...
};
```

Переменная, фугурирующая в описании типа структуры называется полем структуры (компонентой структуры). Такое описание вводит новый тип данных именуемый:
```C
struct имя_типа_структуры
```

Таким образом, впоследствии можно будет описывать переменные с введенным типом:
```C
struct имя_типа_структуры имя_переменной;
```

Примеры.
```C
struct records
{
  char group[20];
  char name[31];
  int min, sec;
};

int main()
{
  struct record a, b; // здесь определены переменные a и b типа struct record
  ...
}
```
Можно объединить описание структуры с описанием переменной:

```C
struct имя_типа_структуры 
{
...
} имя_переменной1, имя_переменной2, ...;
```
Если структура используется для описания только нескольких переменных в одном месте программы, то можно опустить имя_типа_структуры:
```C
struct 
{
...
} имя_переменной1, имя_переменной2, ...;
```

При этом описание переменных этого же типа в другом месте программы будет невозможно.

Переменную типа структуры можно рассматривать как объединение полей структуры, под одним именем. Значение переменной типа структуры распадается на значения входящих в нее полей. Для доступа к полю переменной используется следующая запись:
```C
имя_переменной_типа_структуры.имя_поля
```

Пример.
```C
struct disc
{
  char name; //поле структуры с именем name
  int year;
};

int main()
{
  struct disc d1, d2;
  strcpy(d1.name, "Help!");
  d1.year = 1965; //присваиваем полю year структуры d1 значения 1965.
  strcpy(d2.name, "White Album");
  d2.year = d1.year + 2;
};
```
Примечание: Иногда структуры называют неоднородными массивами (в отличие от обычных массивов, которые являются однородными).

### Присваивание структур

Переменные типа структур можно присваивать друг другу если они относятся к одному и тому же типу.

Пример.
```C
struct records 
{
  char group[30];
  char name[80];
  int min, sec;
};

int main() {
  struct b1, b2;
  strcpy( b1.group, "Pink Floyd" );
  strcpy( b1.name, "The Dark Side Of The Moon");
  b1.min = 43;
  b1.sec = 49;
  b2 = b1;
}
```
При таком присваивании все поля одной структуры будут скопированы в поля другой структуры.

### Указатели на структуры

Структура располагается в памяти в последовательных ячейках. Размер памяти занимаемый структурой является суммой размеров входящих в нее полей (возможно с учетом выравнивания некоторых [на границу слова](https://ru.wikipedia.org/wiki/Выравнивание_данных)).

Пример.

```C
struct 
{
  int i;
  float x;
  char s[ 4 ];
} st;
```
![](Pictures/2.jpg)

Описание указателя на структуру имеет вид:\
```C
struct имя_типа_структуры * имя_переменной;
```

Если p — указатель на структуру, то ссылка на поле структуры имеет вид:

```C
p -> имя_поля
```

### Передача структур в качестве параметра

Передача структур в качестве параметров функций обычно происходит через указатели на структуры.

Пример.

```C
struct xcoord 
{
  int x, y;
  char attr, color;
};


void fun( struct xcoord * st ) { //передаем в функцию указатель st на структуру xcoord 
  struct xccord st1, st2;
  
  st->x = 12; //обращению к полю x структуры xcoord через указатель st
  st->y = 10;
  st->attr = 'A';
  st->color = 0;
  st1 = *st;
  st2.x = st->x;
  ...
}
```

### Вложенные структуры

В качестве полей структур могут быть использованы другие структуры (такие структуры называются вложенными). Такие структуры должны быть определены до содержащей их структуры.

Пример.
```C
struct time 
{
  int min, sec;
};

struct records 
{
  struct time t; //вложенная структура time
  char group[20];
  char name[80];
};

int main()
{
  struct records;

  d.t.min = 43;
  d.t.sec = 10;
  strcpy(d.group, "Deep Purple");
  strcpy(d.name, "Fireball");
  ...
}
```
### Массивы структур

Описание массива структур аналогично описанию массива любого другого типа.

Обработка элементов массива структур производится аналогично обработке элементов массива любого другого типа.

Пример.

```C
struct records audio[30];

int i;

for(i=0; i<30; i++) 
{
  gets(audio[i].group);
  gets(audio[i].name);
  scanf("%d %d", &(audio[i].min), &(audio[i].sec));
}
...
```

### Объединения

Объединение - это средство, позволяющее запоминать данные различных типов в одном и том же месте памяти.

Объединения описываются так же, как и структуры, за исключением того, что вместо ключевого слова *struct* используется ключевое слово *union*.

Доступ к полям объединения осуществляется аналогично доступу к полям структуры.

Пример.
```C
union ttt 
{
  int digit;
  double bigfl;
  char letter;
};

...
unit ttt types;
...
types.digit = 25;
types.bigfl = 2.0;
types.letter = 'S';
...
```

Схема распределения памяти:

![](Pictures/3.jpg)

Использование объединений помогает создавать машинно-независимый (переносимый) код. Поскольку компилятор отслеживает настоящие размеры переменных, образующих объединение, уменьшается зависимость от компьютера. Не нужно беспокоиться о размере целых или вещественных чисел, символов или чего-либо еще.

Объединения часто используются при необходимости преобразования типов, поскольку можно обращаться к данным, хранящимся в объединении, совершенно различными способами.





## Препроцессор

Препроцессор выполняет предварительную обработку исходного текста на языке C, осуществляя в нем замены в соответствии со специальными директивами. После работы препроцессора начинает работу собственно компилятор, который уже переводит программу в машинный код.

Директивы препроцессора располагаются в исходном тексте программы и начинаются с символа #.

### Директива #include

Ранее мы уже не раз использовали директиву #include. Теперь рассмотрим ее подробнее

Формат директивы *#include*:
```C
#include <имя_файла>
#include "имя_файла"
```

Когда в тексте программы встречается директива #include, препроцессор ищет указанный за ней файл и включает его содержимое вместо этой директивы. Файл может указываться с помощью абсолютного или относительного пути.

Пример.
```C
#include "mydir\inc\const.h"
#include "d:\other\proto.h"
#include <sys\stat.h>
```

Файл, включаемый директивой #include может содержать пройзвольный текст на языке C. Однако, обычно он содержит заголовки функций, описание констант внешних переменных и так далее (заголовочные файлы, см. предыдущую лекцию).

Если имя файла заключено в угловые скобки, то считается, что файл расположен в одном из стандартных каталогов. Обычно в этих каталогах хранятся заголовочные файлы, поставляемые с компилятором.

Если имя файла указано в кавычках, то поиск файла начинается с текущего каталога, а затем продолжается в стандартных каталогах.

### Директива #define

Формат директивы #define:
```C
#define макроопределение строка_замещения
```
*макроопределение* — имя, составленное по правилам построения имен;

*строка_замещения* — произвольная текстовая строка.

Директива #define указывает препроцессору заменять все вхождения макроопределения в тексте программы на его строку замещения. Процесс замещения называется макрорасширением.

Макроопределение действует с момента появления директивы #define и до конца файла. Макрорасширения не происходит, если макроопределение встречается в текстовой константе.

Пример 1.
```C
#define PI 3.1415
#define EOF -1 // определено в файле stdio.h
#define NULL 0 // определено в файле stdio.h
```

Пример 2.
```C
#define MAX_KEY 9
#define MAX_KEY_STR MAX_KEY + 1
#define MAX_STR 81

static char Key[ MAX_KEY_STR ];

void get_key( char * str, char * key )
{
  int i;
  for( i = 0; i < MAX_KEY; i++ )
    key[ i ] = str[ i ];
  key[ i ] = '\0';
}

void read_line( void )
{
  char str[ MAX_STR ];
  int i;

  for( i = 0; gets( str ); i++ ) 
  {
    get_key( str, Key );
    /* Обработка строки Key */
    .....................
  }
}
```

Макроопределение может содержать параметры, и тогда оно имеет вид:
```C
#define макроопределение( параметры ) строка_замещения
```
*параметры* — это список имен, разделенных запятыми (может быть пустым).

Пример.
```C
#define SQUARE( X ) ((X)*(X))
```
Теперь при использовании макроопределения SQUARE должен быть указан фактический параметр:
```C
int m, n;
float f;

m = 10;
n = SQUARE( m );
f = SQUARE( 1.5 );
```

Препроцессор сначала заменит в строке замещения все вхождения формального параметра X на фактический параметр, а затем заменит макроопределение на полученную строку замещения.

Таким образом будет получен текст:
```C
int m, n;
float f;

m = 10;
n = m*m;
f = 1.5*1.5;
```

Макроопределение может содержать несколько параметров.
```

```
## Операция определения типа typedef

Операция определения типа *typedef* позволяет давать новые имена типам данных, допустимых в языке С.

Общий вид операции *typedef*:
```C
typedef тип имя;
```

где *тип* — любой допустимый языком С тип данных; *имя* — новое имя, назначаемое соответствующему типу данных.

Операция typedef вводит не новые типы, а только синонимы для типов, которые могли бы быть определены другим путем.

Операция typedef напоминает по действию директиву препроцессора #define, но имеет следующие отличия:

1. В отличие от директивы #define операция typedef дает символические имена, но ограничивается только типами данных.

2. Операция typedef выполняется компилятором, а не препроцессором.

Область действия определения типа с использованием операции typedef зависит от расположения ключевого слова typedef.

Если определение находится внутри функции, то область действия локальна и ограничена этой функцией. Если определение расположено вне функции, то область действия глобальна по отношению к функциям, содержащимся в соответствующем исходном файле и расположенным после данного определения.

Пример.

```C
typedef float Real; // определение нового имени для типа float
typedef int Integer, *IntPtr; // определение нового имени для типов int и int *
typedef char Stroka[81]; // определение нового имени для типа массива из 81 символа



```

## Динамическое распределение памяти

До этого мы работали с переменными (и памятью, выделяемую под нее), которые явно инициализировались в программе. Например, данная операция объявляет в программе массив из 81 символа:

```C
int a[81];
```
Объявляет в программе массив из 81 элемента. Но что делать, если количество элементов в массиве заранее неизвестно? Или, если обобщить: что делать, если заранее неизвестно, сколько памяти нужно выделить под переменные любого типа?

В языке Си существует механизм динамического распределения памяти, когда память выделяется во время выполнения программы по мере надобности.

Описание функций распределения памяти находятся в файлах *stdlib.h* или *alloc.h*.

### Функция malloc

Размещает блок памяти определенного размера в байтах.

Описание:

```C
void * malloc(int size);
//size — количество выделяемых байт памяти.
```

В качестве результата функция возвращает указатель на размещенный блок памяти размером size байт. Если блок такого размера разместить не удается, то функция возвращает значение NULL ( константа NULL описана в тех же файлах, в общем-то, равна нулю).

Пример.
```C
#include <stdlib.h>
int main()
{
  int * iptr;
  ...
  iptr = (int *)malloc(2);
  if(iptr == NULL) printf("No memory !\n");
  ...
}
```


### Функция calloc

Размещает блок памяти под определенное количество переменных определенного типа (динамический массив).

Описание:
```C
void * calloc(int nelem, int elsize);
/*
nelem - количество переменных;
elsize - размер в байтах элемента.
*/
```

Возвращает указатель на размещенный блок памяти размером nelem\*elsize байт. Если блок такого размера разместить не удается, то функция возвращает значение NULL.

После размещения выделенный блок памяти инициализируется значением 0.

Пример.
```C
#include <stdlib.h>
int main()
{
  int * iptr;
  int i;
  ...
  iptr = (int *)calloc(10, 2);
  if(iptr == NULL) 
    printf("No memory !\n");
  else
    for(i = 0; i<10; i++)
    {
      *(iptr+i) = i;
    }
  ...
}
```


### Функция освобождения динамически размещенной памяти

Функции malloc и calloc выделяют память из так называемой "кучи" (heap). Куча - это область памяти, из которой можно брать дополнительную память для размещения данных. 

Куча не бесконечна: как и любая память, она может закончиться.

Когда мы динамически выделяем память под нужды программы, мы "занимаем" у кучи на время использования адреса (байты) в памяти. Пока мы используем данную нам кучей память, никая другая программа не может использовать эти адреса. 

Если в нашей программе потребность в динамически выделенной памяти отпадает, мы должны ее "вернуть" обратно в кучу, иначе она останется ~~тяжелым грехом на нашей душе~~ занятой. Если гипотетически представить ситуацию, когда вся память из кучи будет занята, но возвращена обратно не будет, то программы не смогут себе выделить память динамически: ведь выделять уже будет нечего.

Кучу можно представить как банк, а вашу программу - как заёмщика. Когда заёмщику нужны деньги, он берет их у банка с обещанием вернуть в установленный срок (в нашем случае, установленный срок будет тогда, когда надобность в динамически выделенной памяти отпадет, например, в конце программы). Если заёмщик заберет все деньги у банка и ничего не вернет, то банк не сможет никому выдать денег, ведь у самого банка их и нет.

В общем случае, память, которую заняла ваша программа у кучи, будет возвращена обратно с помощью механизмов операционной системы. Однако, хороший стиль требует возвращать память во время исполнения программы (кто взял, тот и вернул).

Для возвращения памяти существует функция free:

```C
void free(void * block);
//block — указатель на ранее размещенный блок памяти с использованием функций malloc или calloc.
```

Пример.
```C
#include <stdlib.h>
int * iptr;
int i;
...
iptr = (int *)calloc(10, 2);
if(iptr == NULL) printf("No memory !\n");
else
for(i = 0; i<10; i++)
*(iptr+i) = i;
...
free(iptr);
...
```

## Пример использования функций динамического распределения памяти.

Давайте рассмотрим использование calloc на примере:

Вводится последовательность целых положительных чисел. Признаком конца последовательности является ввод числа, значение которого не больше 0. Напечатать введенные числа в обратном порядке.

Общая схема:

![](Pictures/1.jpg)

```C
#include <stdio.h>
#include <stdlib.h>

struct s 
{
  int info;
  struct s * ptr; //указатель на структуру s. 
};


main() 
{
  struct s * tmp1, * tmp2;
  int k;
  
  tmp1 = tmp2 = NULL;
  
/*
Алгоритм заполнения последовательности:
1) Обнуляем указатели ptr1,ptr2;
2) Вводим число в переменную k;
3) Если k>0, то переходим к п. 4), иначе переходим к п. 9)
4) Выделяем память под структуру, присваиваем ptr1 адрес выделенной памяти;
5) В поле info структуры, на которую указывает ptr1, помещаем значение из ввода;
6) В поле ptr структуры, на которую указывает ptr1, помещаем адрес ptr2;
7) ptr2 присваиваем значение ptr1 (значение - адрес структуры);
8) Перейти к п. 2);
9) Конец.
*/
  scanf("%d", &k);
  while(k>0) {
    if(!(tmp1 = (struct s *)malloc(sizeof(struct s)))) 
    {
      printf("No memory...\n");
      break;
    }
    tmp1->info = k;
    tmp1->ptr = tmp2;
    tmp2 = tmp1;
    scanf("%d", &k);
  }
  
/*
Алгоритм печати и освобождения памяти:
1) Если tmp2 = NULL, то перейти к п. 7), иначе переходим к п. 2);
2) Выводим число, записанное в поле info структуры, на которую указывает tmp2;
3) tmp1 присваиваем значение поля ptr структуры, на которую указывает tmp2 (переходим к предыдущему элементу);
4) Освобождаем память, выделенную под tmp2;
5) tmp2 присваиваем значение tmp1;
6) Переходим к п. 1);
7) Конец.
*/
  while(tmp2) 
  {
    printf("info = %d\n", tmp2->info);
    tmp1 = tmp2->ptr;
    free(tmp2);
    tmp2 = tmp1;
  }
}
```


## Использование структур и динамически выделенной памяти для реализации структур данных.

Возможность использования динамического распределения памяти позволяет строить достаточно сложные структуры данных, такие как: граф, дерево, стек, очередь и другие.

Для восприятия восхитительной реальности структур данных рекомендуется к прочтению книга Никлауса Вирта [Алгоритмы и структуры данных](http://tka4.org/materials/lib/Articles-Books/Numerical%20Algorithms/%D0%92%D0%B8%D1%80%D1%82%20%D0%9D.%20%D0%90%D0%9B%D0%93%D0%9E%D0%A0%D0%98%D0%A2%D0%9C%D0%AB%20%D0%98%20%D0%A1%D0%A2%D0%A0%D0%A3%D0%9A%D0%A2%D0%A3%D0%A0%D0%AB%20%D0%94%D0%90%D0%9D%D0%9D%D0%AB%D0%A5.%20%D0%9C.%D0%9C%D0%B8%D1%80%201989.pdf)  или любой другой [источник](http://google.com).

Ниже будут рассмотрены примеры построения структуры данных стек.

### Стек

Стек (stack) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел).

Зачастую стек реализуется в виде однонаправленного списка (каждый элемент в списке содержит помимо хранимой информации в стеке указатель на следующий элемент стека).

Структура, описывающая целочисленный элемент стека, может выглядеть так:

```C
struct stack
{
    int element; //значение элемента
    struct stack *prev; //указатель на предыдущий элемент (структуру)
};
```

Возможны три операции со стеком: добавление элемента (*push*), удаление элемента (*pop*) и чтение верхнего элемента стека или всего стека - в зависимости от потребностей программиста.

При проталкивании (push) добавляется новый элемент, указывающий на элемент, бывший до этого головой. Новый элемент теперь становится головным.

При удалении элемента (pop) убирается первый, а головным становится тот, на который был указатель у этого объекта (следующий элемент). При этом pop как функция возвращает значение вытолкнутого элемента.

![](Pictures/4.jpg)

[Здесь](https://github.com/nikjags/C/tree/master/Lecture%203/stack) можно посмотреть одну из возможных реализаций стека на языке Си.

# ДЗ
Теория:

 - Книга Кернигана и Ритчи. До конца. И посмотреть стандартные библиотеки
 - Желательно полистать [Никлауса Вирта](http://tka4.org/materials/lib/Articles-Books/Numerical%20Algorithms/%D0%92%D0%B8%D1%80%D1%82%20%D0%9D.%20%D0%90%D0%9B%D0%93%D0%9E%D0%A0%D0%98%D0%A2%D0%9C%D0%AB%20%D0%98%20%D0%A1%D0%A2%D0%A0%D0%A3%D0%9A%D0%A2%D0%A3%D0%A0%D0%AB%20%D0%94%D0%90%D0%9D%D0%9D%D0%AB%D0%A5.%20%D0%9C.%D0%9C%D0%B8%D1%80%201989.pdf)
 - Рекомендуется посмотреть реализации деревьев в интернетах;
 
Практика: 

- Реализовать двоичное дерево поиска (любого понравившегося вам вида) и соответствующие ему функции добавления, удаления элемента, обхода дерева. Подробнее о деревьях можно посмотреть [всё у того же Вирта](http://tka4.org/materials/lib/Articles-Books/Numerical%20Algorithms/%D0%92%D0%B8%D1%80%D1%82%20%D0%9D.%20%D0%90%D0%9B%D0%93%D0%9E%D0%A0%D0%98%D0%A2%D0%9C%D0%AB%20%D0%98%20%D0%A1%D0%A2%D0%A0%D0%A3%D0%9A%D0%A2%D0%A3%D0%A0%D0%AB%20%D0%94%D0%90%D0%9D%D0%9D%D0%AB%D0%A5.%20%D0%9C.%D0%9C%D0%B8%D1%80%201989.pdf), или [здесь](https://habrahabr.ru/post/150732/), или в любом другом [источнике](http://google.com). 

Свои вопросы и реализации присылайте мне на почту: n.golubev@lambda-it.ru.



